// Zen Standard Library: Extended Math Module
// Advanced mathematical functions including trigonometry and statistics

comptime {
    core := @std.core
    math := @std.math
}

// Trigonometric functions (using Taylor series approximations)

// Sine function using Taylor series
sin = (x: f64) f64 {
    // Normalize angle to [-PI, PI]
    x = math.wrap_angle(x)
    
    // Taylor series: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    result ::= x
    term ::= x
    x_squared := x * x
    
    // 10 terms for reasonable accuracy
    i ::= 1
    loop (i < 10) {
        term = -term * x_squared / ((2.0 * i) * (2.0 * i + 1.0))
        result = result + term
        i = i + 1
    }
    
    return result
}

// Cosine function using Taylor series
cos = (x: f64) f64 {
    // Normalize angle to [-PI, PI]
    x = math.wrap_angle(x)
    
    // Taylor series: cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...
    result ::= 1.0
    term ::= 1.0
    x_squared := x * x
    
    // 10 terms for reasonable accuracy
    i ::= 1
    loop (i < 10) {
        term = -term * x_squared / ((2.0 * i - 1.0) * (2.0 * i))
        result = result + term
        i = i + 1
    }
    
    return result
}

// Tangent function
tan = (x: f64) f64 {
    c := cos(x)
    math.abs_f64(c) < 0.00000001 ? | true => {
        // Return infinity-like value for vertical asymptotes
        return x > 0 ? | true => 1.0e308 | false => -1.0e308
    } | false => {}
    
    return sin(x) / c
}

// Arc sine (inverse sine) using Newton's method
asin = (x: f64) f64 {
    math.abs_f64(x) > 1.0 ? | true => return 0.0 / 0.0  // NaN for invalid input
                           | false => {}
    
    // Special cases
    x == 0.0 ? | true => return 0.0 | false => {}
    x == 1.0 ? | true => return math.PI / 2.0 | false => {}
    x == -1.0 ? | true => return -math.PI / 2.0 | false => {}
    
    // Newton's method approximation
    result ::= x
    i ::= 0
    loop (i < 10) {
        sine := sin(result)
        derivative := cos(result)
        
        math.abs_f64(derivative) < 0.00001 ? | true => break | false => {}
        
        result = result - (sine - x) / derivative
        i = i + 1
    }
    
    return result
}

// Arc cosine (inverse cosine)
acos = (x: f64) f64 {
    math.abs_f64(x) > 1.0 ? | true => return 0.0 / 0.0  // NaN
                           | false => {}
    
    return math.PI / 2.0 - asin(x)
}

// Arc tangent (inverse tangent)
atan = (x: f64) f64 {
    // Using the identity: atan(x) = asin(x / sqrt(1 + x^2))
    return asin(x / math.sqrt_f64(1.0 + x * x))
}

// Arc tangent of y/x (handles quadrants correctly)
atan2 = (y: f64, x: f64) f64 {
    x == 0.0 && y == 0.0 ? | true => return 0.0 | false => {}
    
    x == 0.0 ? | true => {
        return y > 0.0 ? | true => math.PI / 2.0 
                        | false => -math.PI / 2.0
    } | false => {}
    
    x > 0.0 ? | true => return atan(y / x) | false => {}
    
    y >= 0.0 ? | true => return atan(y / x) + math.PI
              | false => return atan(y / x) - math.PI
}

// Hyperbolic functions

// Hyperbolic sine
sinh = (x: f64) f64 {
    e_x := exp(x)
    return (e_x - 1.0 / e_x) / 2.0
}

// Hyperbolic cosine
cosh = (x: f64) f64 {
    e_x := exp(x)
    return (e_x + 1.0 / e_x) / 2.0
}

// Hyperbolic tangent
tanh = (x: f64) f64 {
    x > 20.0 ? | true => return 1.0 | false => {}
    x < -20.0 ? | true => return -1.0 | false => {}
    
    e_2x := exp(2.0 * x)
    return (e_2x - 1.0) / (e_2x + 1.0)
}

// Exponential and logarithmic functions

// Exponential function e^x using Taylor series
exp = (x: f64) f64 {
    // Handle edge cases
    x > 700.0 ? | true => return 1.0e308 | false => {}  // Prevent overflow
    x < -700.0 ? | true => return 0.0 | false => {}
    
    // Taylor series: e^x = 1 + x + x^2/2! + x^3/3! + ...
    result ::= 1.0
    term ::= 1.0
    
    i ::= 1
    loop (i < 100) {  // More terms for better accuracy
        term = term * x / i
        new_result := result + term
        
        // Check for convergence
        math.abs_f64(new_result - result) < 0.00000001 ? | true => break | false => {}
        
        result = new_result
        i = i + 1
    }
    
    return result
}

// Natural logarithm using Newton's method
log = (x: f64) f64 {
    x <= 0.0 ? | true => return 0.0 / 0.0  // NaN for invalid input
              | false => {}
    
    x == 1.0 ? | true => return 0.0 | false => {}
    
    // Use the property: log(x) = log(x/2^n) + n*log(2)
    // to bring x closer to 1 for better convergence
    n ::= 0
    y ::= x
    loop (y > 2.0) {
        y = y / 2.0
        n = n + 1
    }
    
    loop (y < 0.5) {
        y = y * 2.0
        n = n - 1
    }
    
    // Newton's method for log(y) where y is close to 1
    result ::= y - 1.0  // Initial guess
    i ::= 0
    loop (i < 20) {
        e_result := exp(result)
        result = result - (e_result - y) / e_result
        i = i + 1
    }
    
    return result + n * math.LN2
}

// Logarithm base 10
log10 = (x: f64) f64 {
    return log(x) / math.LN10
}

// Logarithm base 2
log2 = (x: f64) f64 {
    return log(x) / math.LN2
}

// Power function x^y (handles fractional and negative exponents)
pow = (x: f64, y: f64) f64 {
    // Special cases
    y == 0.0 ? | true => return 1.0 | false => {}
    x == 0.0 ? | true => return y > 0.0 ? | true => 0.0 | false => 1.0 / 0.0 | false => {}
    y == 1.0 ? | true => return x | false => {}
    
    // Integer power optimization
    y_int := y as i64
    y == y_int ? | true => {
        result ::= 1.0
        base ::= x
        exp ::= math.abs_i64(y_int)
        
        loop (exp > 0) {
            exp & 1 == 1 ? | true => result = result * base | false => {}
            base = base * base
            exp = exp >> 1
        }
        
        return y < 0.0 ? | true => 1.0 / result | false => result
    } | false => {}
    
    // General case: x^y = exp(y * log(x))
    x < 0.0 ? | true => return 0.0 / 0.0  // NaN for negative base with non-integer exponent
             | false => {}
    
    return exp(y * log(x))
}

// Statistical functions

// Calculate mean of array
mean = (values: *f64, count: i64) f64 {
    count <= 0 ? | true => return 0.0 / 0.0 | false => {}
    
    sum ::= 0.0
    i ::= 0
    loop (i < count) {
        sum = sum + values[i]
        i = i + 1
    }
    
    return sum / count
}

// Calculate variance
variance = (values: *f64, count: i64) f64 {
    count <= 0 ? | true => return 0.0 / 0.0 | false => {}
    
    avg := mean(values, count)
    sum_sq ::= 0.0
    
    i ::= 0
    loop (i < count) {
        diff := values[i] - avg
        sum_sq = sum_sq + diff * diff
        i = i + 1
    }
    
    return sum_sq / count
}

// Calculate standard deviation
std_dev = (values: *f64, count: i64) f64 {
    return math.sqrt_f64(variance(values, count))
}

// Random number generation (Linear Congruential Generator)
// This is a simple PRNG, not cryptographically secure

RNG = {
    seed: i64,
}

// Create new RNG with seed
rng_new = (seed: i64) RNG {
    return RNG { seed: seed }
}

// Generate next random number in [0, 1)
rng_next = (rng: *RNG) f64 {
    // LCG parameters (from Numerical Recipes)
    a :: i64 = 1664525
    c :: i64 = 1013904223
    m :: i64 = 2147483648  // 2^31
    
    rng.seed = (a * rng.seed + c) % m
    return rng.seed as f64 / m
}

// Generate random integer in range [min, max)
rng_int_range = (rng: *RNG, min: i64, max: i64) i64 {
    min >= max ? | true => return min | false => {}
    
    range := max - min
    return min + (rng_next(rng) * range) as i64
}

// Generate random float in range [min, max)
rng_float_range = (rng: *RNG, min: f64, max: f64) f64 {
    return min + rng_next(rng) * (max - min)
}

// Generate normally distributed random number (Box-Muller transform)
rng_normal = (rng: *RNG, mean: f64, std_dev: f64) f64 {
    // Generate two uniform random numbers
    u1 := rng_next(rng)
    u2 := rng_next(rng)
    
    // Avoid log(0)
    u1 < 0.00001 ? | true => u1 = 0.00001 | false => {}
    
    // Box-Muller transform
    z0 := math.sqrt_f64(-2.0 * log(u1)) * cos(2.0 * math.PI * u2)
    
    return mean + z0 * std_dev
}

// Matrix operations (2D)

Matrix2 = {
    m00: f64, m01: f64,
    m10: f64, m11: f64,
}

// Create 2x2 identity matrix
matrix2_identity = () Matrix2 {
    return Matrix2 {
        m00: 1.0, m01: 0.0,
        m10: 0.0, m11: 1.0,
    }
}

// Create 2x2 rotation matrix
matrix2_rotation = (angle: f64) Matrix2 {
    c := cos(angle)
    s := sin(angle)
    return Matrix2 {
        m00: c, m01: -s,
        m10: s, m11: c,
    }
}

// Multiply two 2x2 matrices
matrix2_multiply = (a: Matrix2, b: Matrix2) Matrix2 {
    return Matrix2 {
        m00: a.m00 * b.m00 + a.m01 * b.m10,
        m01: a.m00 * b.m01 + a.m01 * b.m11,
        m10: a.m10 * b.m00 + a.m11 * b.m10,
        m11: a.m10 * b.m01 + a.m11 * b.m11,
    }
}

// Calculate 2x2 matrix determinant
matrix2_determinant = (m: Matrix2) f64 {
    return m.m00 * m.m11 - m.m01 * m.m10
}

// Invert 2x2 matrix
matrix2_inverse = (m: Matrix2) core.Result<Matrix2, core.Error> {
    det := matrix2_determinant(m)
    
    math.abs_f64(det) < 0.00001 ? | true => {
        return core.Result::Err(core.Error::InvalidArgument("Matrix is singular"))
    } | false => {}
    
    inv_det := 1.0 / det
    
    return core.Result::Ok(Matrix2 {
        m00: m.m11 * inv_det,
        m01: -m.m01 * inv_det,
        m10: -m.m10 * inv_det,
        m11: m.m00 * inv_det,
    })
}