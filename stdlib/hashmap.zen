// Zen Standard Library: HashMap Implementation
// A hash table implementation with linear probing

comptime {
    core := @std.core
}

// Hash map entry
Entry<K, V> = {
    key: K,
    value: V,
    occupied: bool,
    deleted: bool,
}

// HashMap structure
HashMap<K, V> = {
    buckets: *Entry<K, V>,
    size: i64,          // Number of key-value pairs
    capacity: i64,      // Total bucket capacity
    load_factor: f64,   // Maximum load factor before resize
}

// Default hash function for integers
hash_i64 = (key: i64) i64 {
    // Simple hash function - can be improved
    x ::= key
    x = ((x >> 16) ^ x) * 0x45d9f3b
    x = ((x >> 16) ^ x) * 0x45d9f3b
    x = (x >> 16) ^ x
    return x
}

// Hash function for strings (simplified)
hash_string = (key: string) i64 {
    hash ::= 5381i64
    i ::= 0
    // Would iterate through string characters
    // For now, using a simplified version
    return hash
}

// Create new hashmap
hashmap_new<K, V> = () HashMap<K, V> {
    return HashMap<K, V> {
        buckets: 0,
        size: 0,
        capacity: 0,
        load_factor: 0.75,
    }
}

// Create hashmap with initial capacity
hashmap_with_capacity<K, V> = (capacity: i64) core.Result<HashMap<K, V>, core.Error> {
    capacity <= 0 ? | true => {
        return core.Result::Err(core.Error::InvalidArgument("Capacity must be positive"))
    } | false => {}
    
    // Allocate buckets
    bucket_size := sizeof(Entry<K, V>)
    buckets := core.malloc(capacity * bucket_size)
    buckets == 0 ? | true => {
        return core.Result::Err(core.Error::OutOfMemory)
    } | false => {}
    
    // Initialize buckets as empty
    i ::= 0
    loop i < capacity {
        buckets[i] = Entry<K, V> {
            key: {},
            value: {},
            occupied: false,
            deleted: false,
        }
        i = i + 1
    }
    
    return core.Result::Ok(HashMap<K, V> {
        buckets: buckets,
        size: 0,
        capacity: capacity,
        load_factor: 0.75,
    })
}

// Find bucket index for a key
find_bucket<K, V> = (map: *HashMap<K, V>, key: K, hash_func: (K) i64) i64 {
    map.capacity == 0 ? | true => return -1
                        | false => {}
    
    hash := hash_func(key)
    index ::= core.abs(hash) % map.capacity
    
    // Linear probing to find key or empty slot
    loop {
        bucket := map.buckets[index]
        
        // Found empty slot or matching key
        !bucket.occupied || (bucket.occupied && !bucket.deleted && bucket.key == key) ? 
            | true => return index
            | false => {}
        
        // Continue probing
        index = (index + 1) % map.capacity
    }
}

// Insert key-value pair
hashmap_insert<K, V> = (map: *HashMap<K, V>, key: K, value: V, hash_func: (K) i64) core.Result<void, core.Error> {
    // Check if resize needed
    map.capacity == 0 || (map.size as f64) >= (map.capacity as f64) * map.load_factor ? | true => {
        new_capacity := map.capacity == 0 ? | true => 16
                                           | false => map.capacity * 2
        result := hashmap_resize(map, new_capacity, hash_func)
        result ? | .Err -> e => return core.Result::Err(e)
                | .Ok -> _ => {}
    } | false => {}
    
    index := find_bucket(map, key, hash_func)
    index == -1 ? | true => {
        return core.Result::Err(core.Error::InvalidArgument("Invalid bucket index"))
    } | false => {}
    
    bucket := &map.buckets[index]
    
    // Update size if inserting new key
    !bucket.occupied || bucket.deleted ? | true => {
        map.size = map.size + 1
    } | false => {}
    
    bucket.key = key
    bucket.value = value
    bucket.occupied = true
    bucket.deleted = false
    
    return core.Result::Ok({})
}

// Get value for key
hashmap_get<K, V> = (map: *HashMap<K, V>, key: K, hash_func: (K) i64) core.Option<V> {
    map.capacity == 0 ? | true => return core.Option::None
                        | false => {}
    
    index := find_bucket(map, key, hash_func)
    index == -1 ? | true => return core.Option::None
                 | false => {}
    
    bucket := map.buckets[index]
    bucket.occupied && !bucket.deleted ? | true => return core.Option::Some(bucket.value)
                                        | false => return core.Option::None
}

// Remove key-value pair
hashmap_remove<K, V> = (map: *HashMap<K, V>, key: K, hash_func: (K) i64) core.Option<V> {
    map.capacity == 0 ? | true => return core.Option::None
                        | false => {}
    
    index := find_bucket(map, key, hash_func)
    index == -1 ? | true => return core.Option::None
                 | false => {}
    
    bucket := &map.buckets[index]
    bucket.occupied && !bucket.deleted ? | true => {
        value := bucket.value
        bucket.deleted = true
        map.size = map.size - 1
        return core.Option::Some(value)
    } | false => {
        return core.Option::None
    }
}

// Check if key exists
hashmap_contains<K, V> = (map: *HashMap<K, V>, key: K, hash_func: (K) i64) bool {
    result := hashmap_get(map, key, hash_func)
    return result ? | .Some -> _ => true
                   | .None => false
}

// Get hashmap size
hashmap_len<K, V> = (map: *HashMap<K, V>) i64 {
    return map.size
}

// Check if hashmap is empty
hashmap_is_empty<K, V> = (map: *HashMap<K, V>) bool {
    return map.size == 0
}

// Clear hashmap
hashmap_clear<K, V> = (map: *HashMap<K, V>) void {
    i ::= 0
    loop i < map.capacity {
        map.buckets[i].occupied = false
        map.buckets[i].deleted = false
        i = i + 1
    }
    map.size = 0
}

// Resize hashmap
hashmap_resize<K, V> = (map: *HashMap<K, V>, new_capacity: i64, hash_func: (K) i64) core.Result<void, core.Error> {
    // Save old buckets
    old_buckets := map.buckets
    old_capacity := map.capacity
    
    // Allocate new buckets
    bucket_size := sizeof(Entry<K, V>)
    new_buckets := core.malloc(new_capacity * bucket_size)
    new_buckets == 0 ? | true => {
        return core.Result::Err(core.Error::OutOfMemory)
    } | false => {}
    
    // Initialize new buckets
    i ::= 0
    loop i < new_capacity {
        new_buckets[i] = Entry<K, V> {
            key: {},
            value: {},
            occupied: false,
            deleted: false,
        }
        i = i + 1
    }
    
    // Update map
    map.buckets = new_buckets
    map.capacity = new_capacity
    map.size = 0
    
    // Rehash all entries
    i = 0
    loop i < old_capacity {
        entry := old_buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            result := hashmap_insert(map, entry.key, entry.value, hash_func)
            result ? | .Err -> _ => {} // Ignore errors during rehashing
                    | .Ok -> _ => {}
        } | false => {}
        i = i + 1
    }
    
    // Free old buckets
    old_buckets != 0 ? | true => {
        core.free(old_buckets)
    } | false => {}
    
    return core.Result::Ok({})
}

// Free hashmap memory
hashmap_free<K, V> = (map: *HashMap<K, V>) void {
    map.buckets != 0 ? | true => {
        core.free(map.buckets)
    } | false => {}
    
    map.buckets = 0
    map.size = 0
    map.capacity = 0
}

// ===== Additional HashMap Methods =====

// Get or insert with default value
hashmap_get_or_insert<K, V> = (map: *HashMap<K, V>, key: K, default: V, hash_func: (K) i64) core.Result<V, core.Error> {
    existing := hashmap_get(map, key, hash_func)
    existing ? | .Some -> value => return core.Result::Ok(value)
              | .None => {
        result := hashmap_insert(map, key, default, hash_func)
        result ? | .Err -> e => return core.Result::Err(e)
                | .Ok -> _ => return core.Result::Ok(default)
    }
}

// Update value if key exists
hashmap_update<K, V> = (map: *HashMap<K, V>, key: K, updater: (V) V, hash_func: (K) i64) bool {
    map.capacity == 0 ? | true => return false | false => {}
    
    index := find_bucket(map, key, hash_func)
    index == -1 ? | true => return false | false => {}
    
    bucket := &map.buckets[index]
    bucket.occupied && !bucket.deleted ? | true => {
        bucket.value = updater(bucket.value)
        return true
    } | false => {
        return false
    }
}

// Get all keys
hashmap_keys<K, V> = (map: *HashMap<K, V>) core.Result<core.Vec<K>, core.Error> {
    keys := core.vec_with_capacity<K>(map.size)
    keys ? | .Err -> e => return core.Result::Err(e)
          | .Ok -> vec => {
        i ::= 0
        loop i < map.capacity {
            entry := map.buckets[i]
            entry.occupied && !entry.deleted ? | true => {
                result := core.vec_push(&vec, entry.key)
                result ? | .Err -> e => return core.Result::Err(e)
                        | .Ok -> _ => {}
            } | false => {}
            i = i + 1
        }
        return core.Result::Ok(vec)
    }
}

// Get all values
hashmap_values<K, V> = (map: *HashMap<K, V>) core.Result<core.Vec<V>, core.Error> {
    values := core.vec_with_capacity<V>(map.size)
    values ? | .Err -> e => return core.Result::Err(e)
            | .Ok -> vec => {
        i ::= 0
        loop i < map.capacity {
            entry := map.buckets[i]
            entry.occupied && !entry.deleted ? | true => {
                result := core.vec_push(&vec, entry.value)
                result ? | .Err -> e => return core.Result::Err(e)
                        | .Ok -> _ => {}
            } | false => {}
            i = i + 1
        }
        return core.Result::Ok(vec)
    }
}

// Apply function to each key-value pair
hashmap_for_each<K, V> = (map: *HashMap<K, V>, f: (K, V) void) void {
    i ::= 0
    loop i < map.capacity {
        entry := map.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            f(entry.key, entry.value)
        } | false => {}
        i = i + 1
    }
}

// Count entries matching predicate
hashmap_count<K, V> = (map: *HashMap<K, V>, predicate: (K, V) bool) i64 {
    count ::= 0
    i ::= 0
    loop i < map.capacity {
        entry := map.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            predicate(entry.key, entry.value) ? | true => {
                count = count + 1
            } | false => {}
        } | false => {}
        i = i + 1
    }
    return count
}

// Filter entries into new hashmap
hashmap_filter<K, V> = (map: *HashMap<K, V>, predicate: (K, V) bool, hash_func: (K) i64) core.Result<HashMap<K, V>, core.Error> {
    filtered := hashmap_new<K, V>()
    
    i ::= 0
    loop i < map.capacity {
        entry := map.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            predicate(entry.key, entry.value) ? | true => {
                result := hashmap_insert(&filtered, entry.key, entry.value, hash_func)
                result ? | .Err -> e => return core.Result::Err(e)
                        | .Ok -> _ => {}
            } | false => {}
        } | false => {}
        i = i + 1
    }
    return core.Result::Ok(filtered)
}

// Merge two hashmaps (values from other override values in self)
hashmap_merge<K, V> = (map: *HashMap<K, V>, other: *HashMap<K, V>, hash_func: (K) i64) core.Result<void, core.Error> {
    i ::= 0
    loop i < other.capacity {
        entry := other.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            result := hashmap_insert(map, entry.key, entry.value, hash_func)
            result ? | .Err -> e => return core.Result::Err(e)
                    | .Ok -> _ => {}
        } | false => {}
        i = i + 1
    }
    return core.Result::Ok({})
}

// Clone hashmap
hashmap_clone<K, V> = (map: *HashMap<K, V>, hash_func: (K) i64) core.Result<HashMap<K, V>, core.Error> {
    cloned := hashmap_with_capacity<K, V>(map.capacity)
    cloned ? | .Err -> e => return core.Result::Err(e)
            | .Ok -> new_map => {
        i ::= 0
        loop i < map.capacity {
            entry := map.buckets[i]
            entry.occupied && !entry.deleted ? | true => {
                result := hashmap_insert(&new_map, entry.key, entry.value, hash_func)
                result ? | .Err -> e => return core.Result::Err(e)
                        | .Ok -> _ => {}
            } | false => {}
            i = i + 1
        }
        return core.Result::Ok(new_map)
    }
}

// Get capacity
hashmap_capacity<K, V> = (map: *HashMap<K, V>) i64 {
    return map.capacity
}

// Set load factor
hashmap_set_load_factor<K, V> = (map: *HashMap<K, V>, load_factor: f64) void {
    load_factor > 0.0 && load_factor < 1.0 ? | true => {
        map.load_factor = load_factor
    } | false => {}
}

// Compute with entry (for complex updates)
hashmap_compute<K, V> = (map: *HashMap<K, V>, key: K, computer: (core.Option<V>) core.Option<V>, hash_func: (K) i64) core.Result<void, core.Error> {
    current := hashmap_get(map, key, hash_func)
    new_value := computer(current)
    
    new_value ? | .Some -> value => {
        return hashmap_insert(map, key, value, hash_func)
    } | .None => {
        current ? | .Some -> _ => {
            hashmap_remove(map, key, hash_func)
            return core.Result::Ok({})
        } | .None => {
            return core.Result::Ok({})
        }
    }
}

// Check if any entry matches predicate
hashmap_any<K, V> = (map: *HashMap<K, V>, predicate: (K, V) bool) bool {
    i ::= 0
    loop i < map.capacity {
        entry := map.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            predicate(entry.key, entry.value) ? | true => return true | false => {}
        } | false => {}
        i = i + 1
    }
    return false
}

// Check if all entries match predicate
hashmap_all<K, V> = (map: *HashMap<K, V>, predicate: (K, V) bool) bool {
    i ::= 0
    loop i < map.capacity {
        entry := map.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            predicate(entry.key, entry.value) ? | false => return false | true => {}
        } | false => {}
        i = i + 1
    }
    return true
}

// Find first entry matching predicate
hashmap_find<K, V> = (map: *HashMap<K, V>, predicate: (K, V) bool) core.Option<(K, V)> {
    i ::= 0
    loop i < map.capacity {
        entry := map.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            predicate(entry.key, entry.value) ? | true => {
                return core.Option::Some((entry.key, entry.value))
            } | false => {}
        } | false => {}
        i = i + 1
    }
    return core.Option::None
}

// Functional loop method for HashMap - executes callback for each key-value pair
HashMap<K, V>.loop = (self: *HashMap<K, V>, callback: (K, V) void) void {
    i ::= 0
    loop i < self.capacity {
        entry := self.buckets[i]
        entry.occupied && !entry.deleted ? | true => {
            callback(entry.key, entry.value)
        } | false => {}
        i = i + 1
    }
}