// Random number generation utilities for Zen

comptime {
    std := @std
    core := std.core
}

// Random number generator state
RandomState = {
    seed:: u64,
    state:: u64,
}

// Initialize a new random state with given seed
new_random = (seed: u64) RandomState {
    RandomState {
        seed: seed,
        state: seed,
    }
}

// Get system random seed (using current time)
system_seed = () u64 {
    // In real implementation, would use system time or entropy
    // For now, return a fixed seed for determinism
    0x853c49e6748fea9b
}

// Linear congruential generator (LCG)
// Using parameters from Numerical Recipes
next_u64 = (rng:: Ref<RandomState>) u64 {
    rng.state = rng.state * 1664525 + 1013904223
    rng.state
}

// Generate random u32
next_u32 = (rng:: Ref<RandomState>) u32 {
    (next_u64(rng) >> 32): u32
}

// Generate random integer in range [min, max)
next_int_range = (rng:: Ref<RandomState>, min: i32, max: i32) i32 {
    range := (max - min): u32
    range == 0 ? | true => min
                | false => {
                    value := next_u32(rng) % range
                    min + value: i32
                }
}

// Generate random float in [0, 1)
next_f32 = (rng:: Ref<RandomState>) f32 {
    // Use upper 24 bits for mantissa (float32 has 23-bit mantissa)
    mantissa := (next_u64(rng) >> 40): u32
    mantissa: f32 / 16777216.0  // 2^24
}

// Generate random float in [0, 1)
next_f64 = (rng:: Ref<RandomState>) f64 {
    // Use upper 53 bits for mantissa (float64 has 52-bit mantissa)
    mantissa := next_u64(rng) >> 11
    mantissa: f64 / 9007199254740992.0  // 2^53
}

// Generate random boolean
next_bool = (rng:: Ref<RandomState>) bool {
    (next_u64(rng) & 1) == 1
}

// Shuffle an array in-place using Fisher-Yates algorithm
shuffle = <T>(rng:: Ref<RandomState>, arr:: Ref<Array<T>>, len: usize) void {
    i ::= len
    loop i > 1 {
        i = i - 1
        j := next_int_range(rng, 0, i: i32): usize
        // Swap elements at i and j
        temp := arr[i]
        arr[i] = arr[j]
        arr[j] = temp
    }
}

// Generate random bytes
random_bytes = (rng:: Ref<RandomState>, buffer:: Ref<Array<u8>>, len: usize) void {
    i ::= 0: usize
    loop i < len {
        buffer[i] = next_u32(rng): u8
        i = i + 1
    }
}

// Global random state for convenience
global_rng ::= new_random(system_seed())

// Convenience functions using global state
rand = () f64 { next_f64(&global_rng) }
rand_f32 = () f32 { next_f32(&global_rng) }
rand_int = (min: i32, max: i32) i32 { next_int_range(&global_rng, min, max) }
rand_bool = () bool { next_bool(&global_rng) }

// Seed the global generator
seed = (s: u64) void {
    global_rng.seed = s
    global_rng.state = s
}