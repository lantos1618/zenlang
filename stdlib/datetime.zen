// Date and time utilities for Zen

comptime {
    std := @std
    core := std.core
}

// Time duration in nanoseconds
Duration = {
    nanos: i64,
}

// Date and time representation
DateTime = {
    year: i32,
    month: u8,    // 1-12
    day: u8,      // 1-31
    hour: u8,     // 0-23
    minute: u8,   // 0-59
    second: u8,   // 0-59
    nanos: u32,   // 0-999999999
}

// Day of week enumeration
DayOfWeek = 
    | Monday
    | Tuesday
    | Wednesday
    | Thursday
    | Friday
    | Saturday
    | Sunday

// Month enumeration
Month = 
    | January
    | February
    | March
    | April
    | May
    | June
    | July
    | August
    | September
    | October
    | November
    | December

// Duration constants
NANOSECOND := 1: i64
MICROSECOND := 1000 * NANOSECOND
MILLISECOND := 1000 * MICROSECOND
SECOND := 1000 * MILLISECOND
MINUTE := 60 * SECOND
HOUR := 60 * MINUTE
DAY := 24 * HOUR
WEEK := 7 * DAY

// Create duration from components
duration_from_secs = (secs: i64) Duration {
    Duration { nanos: secs * SECOND }
}

duration_from_millis = (millis: i64) Duration {
    Duration { nanos: millis * MILLISECOND }
}

duration_from_micros = (micros: i64) Duration {
    Duration { nanos: micros * MICROSECOND }
}

duration_from_nanos = (nanos: i64) Duration {
    Duration { nanos: nanos }
}

// Duration arithmetic
duration_add = (a: Duration, b: Duration) Duration {
    Duration { nanos: a.nanos + b.nanos }
}

duration_sub = (a: Duration, b: Duration) Duration {
    Duration { nanos: a.nanos - b.nanos }
}

duration_mul = (d: Duration, factor: i32) Duration {
    Duration { nanos: d.nanos * factor: i64 }
}

// Duration conversions
as_seconds = (d: Duration) f64 {
    d.nanos: f64 / SECOND: f64
}

as_millis = (d: Duration) i64 {
    d.nanos / MILLISECOND
}

as_micros = (d: Duration) i64 {
    d.nanos / MICROSECOND
}

as_nanos = (d: Duration) i64 {
    d.nanos
}

// Check if year is leap year
is_leap_year = (year: i32) bool {
    year % 4 == 0 ? | true => {
        year % 100 == 0 ? | true => year % 400 == 0
                         | false => true
    }
    | false => false
}

// Days in month
days_in_month = (year: i32, month: u8) u8 {
    month ? | 2 => is_leap_year(year) ? | true => 29: u8
                                       | false => 28: u8
           | 4 | 6 | 9 | 11 => 30: u8
           | _ => 31: u8
}

// Validate date components
is_valid_date = (year: i32, month: u8, day: u8) bool {
    month >= 1 && month <= 12 && day >= 1 && day <= days_in_month(year, month)
}

// Create new DateTime
new_datetime = (year: i32, month: u8, day: u8, hour: u8, minute: u8, second: u8, nanos: u32) Option<DateTime> {
    is_valid_date(year, month, day) && 
    hour < 24 && minute < 60 && second < 60 && nanos < 1000000000 ?
        | true => Some(DateTime {
            year: year,
            month: month,
            day: day,
            hour: hour,
            minute: minute,
            second: second,
            nanos: nanos,
        })
        | false => None
}

// Format DateTime as string (ISO 8601 like)
format_datetime = (dt: DateTime) string {
    // Format: YYYY-MM-DD HH:MM:SS.nnnnnnnnn
    year_str := int_to_string(dt.year)
    month_str := dt.month < 10 ? | true => "0" + int_to_string(dt.month: i32)
                                 | false => int_to_string(dt.month: i32)
    day_str := dt.day < 10 ? | true => "0" + int_to_string(dt.day: i32)
                             | false => int_to_string(dt.day: i32)
    hour_str := dt.hour < 10 ? | true => "0" + int_to_string(dt.hour: i32)
                               | false => int_to_string(dt.hour: i32)
    minute_str := dt.minute < 10 ? | true => "0" + int_to_string(dt.minute: i32)
                                   | false => int_to_string(dt.minute: i32)
    second_str := dt.second < 10 ? | true => "0" + int_to_string(dt.second: i32)
                                   | false => int_to_string(dt.second: i32)
    
    year_str + "-" + month_str + "-" + day_str + " " + 
    hour_str + ":" + minute_str + ":" + second_str
}

// Add duration to datetime
add_duration = (dt: DateTime, d: Duration) DateTime {
    // Simplified implementation - would need proper calendar arithmetic
    total_seconds := dt.second: i64 + (d.nanos / SECOND)
    new_second := (total_seconds % 60): u8
    carry_minutes := total_seconds / 60
    
    total_minutes := dt.minute: i64 + carry_minutes
    new_minute := (total_minutes % 60): u8
    carry_hours := total_minutes / 60
    
    total_hours := dt.hour: i64 + carry_hours
    new_hour := (total_hours % 24): u8
    carry_days := total_hours / 24
    
    // For simplicity, just add days without proper month/year handling
    new_day := dt.day + carry_days: u8
    
    DateTime {
        year: dt.year,
        month: dt.month,
        day: new_day,
        hour: new_hour,
        minute: new_minute,
        second: new_second,
        nanos: dt.nanos + (d.nanos % SECOND): u32,
    }
}

// Compare DateTimes
datetime_before = (a: DateTime, b: DateTime) bool {
    a.year < b.year ? | true => true
                     | false => {
        a.year > b.year ? | true => false
                         | false => {
            a.month < b.month ? | true => true
                               | false => {
                a.month > b.month ? | true => false
                                   | false => {
                    a.day < b.day ? | true => true
                                   | false => {
                        a.day > b.day ? | true => false
                                       | false => {
                            a.hour < b.hour ? | true => true
                                            | false => {
                                a.hour > b.hour ? | true => false
                                                | false => {
                                    a.minute < b.minute ? | true => true
                                                        | false => {
                                        a.minute > b.minute ? | true => false
                                                            | false => {
                                            a.second < b.second ? | true => true
                                                                | false => {
                                                a.second > b.second ? | true => false
                                                                    | false => a.nanos < b.nanos
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

datetime_equal = (a: DateTime, b: DateTime) bool {
    a.year == b.year && a.month == b.month && a.day == b.day &&
    a.hour == b.hour && a.minute == b.minute && a.second == b.second &&
    a.nanos == b.nanos
}

datetime_after = (a: DateTime, b: DateTime) bool {
    !datetime_before(a, b) && !datetime_equal(a, b)
}