// Zen Standard Library: Network Module
// TCP/UDP networking support

// External socket functions
extern socket = (domain: i32, type_: i32, protocol: i32) i32
extern bind = (sockfd: i32, addr: *i8, addrlen: i32) i32
extern listen = (sockfd: i32, backlog: i32) i32
extern accept = (sockfd: i32, addr: *i8, addrlen: *i32) i32
extern connect = (sockfd: i32, addr: *i8, addrlen: i32) i32
extern send = (sockfd: i32, buf: *i8, len: i64, flags: i32) i64
extern recv = (sockfd: i32, buf: *i8, len: i64, flags: i32) i64
extern sendto = (sockfd: i32, buf: *i8, len: i64, flags: i32, dest_addr: *i8, addrlen: i32) i64
extern recvfrom = (sockfd: i32, buf: *i8, len: i64, flags: i32, src_addr: *i8, addrlen: *i32) i64
extern close = (fd: i32) i32
extern shutdown = (sockfd: i32, how: i32) i32
extern setsockopt = (sockfd: i32, level: i32, optname: i32, optval: *i8, optlen: i32) i32
extern getsockopt = (sockfd: i32, level: i32, optname: i32, optval: *i8, optlen: *i32) i32
extern inet_addr = (cp: *i8) i32
extern htons = (hostshort: i16) i16
extern htonl = (hostlong: i32) i32
extern ntohs = (netshort: i16) i16
extern ntohl = (netlong: i32) i32

// Socket domain constants
AF_UNIX := 1     // Local socket
AF_INET := 2     // IPv4
AF_INET6 := 10   // IPv6

// Socket type constants
SOCK_STREAM := 1     // TCP
SOCK_DGRAM := 2      // UDP
SOCK_RAW := 3        // Raw socket

// Protocol constants
IPPROTO_TCP := 6
IPPROTO_UDP := 17
IPPROTO_ICMP := 1

// Shutdown options
SHUT_RD := 0    // Disable reading
SHUT_WR := 1    // Disable writing
SHUT_RDWR := 2  // Disable both

// Socket option levels
SOL_SOCKET := 1
IPPROTO_TCP_LEVEL := 6

// Socket options
SO_REUSEADDR := 2
SO_KEEPALIVE := 9
SO_BROADCAST := 6
SO_RCVBUF := 8
SO_SNDBUF := 7
TCP_NODELAY := 1

// Default buffer size
DEFAULT_BUFFER_SIZE := 4096

// Address family type
AddressFamily = 
    | IPv4
    | IPv6
    | Unix

// Socket type
SocketType = 
    | TCP
    | UDP
    | Raw

// Network errors
NetError = 
    | ConnectionRefused
    | ConnectionReset
    | ConnectionAborted
    | NotConnected
    | AddrInUse
    | AddrNotAvailable
    | NetworkDown
    | NetworkUnreachable
    | HostUnreachable
    | TimedOut
    | PermissionDenied
    | InvalidAddress
    | Other

// Result type for network operations
NetResult<T> = 
    | Ok(value: T)
    | Err(error: NetError)

// IP Address representation
IpAddr = 
    | V4(a: i8, b: i8, c: i8, d: i8)
    | V6(addr: *i8)  // Simplified for now

// Socket address
SocketAddr = {
    ip: IpAddr,
    port: i16,
}

// TCP Socket
TcpSocket = {
    fd: i32,
    local_addr: SocketAddr,
    peer_addr: SocketAddr,
    is_connected: bool,
}

// UDP Socket
UdpSocket = {
    fd: i32,
    local_addr: SocketAddr,
    is_bound: bool,
}

// TCP Listener
TcpListener = {
    fd: i32,
    local_addr: SocketAddr,
    is_listening: bool,
}

// Create a new TCP socket
tcp_socket_new = () NetResult<TcpSocket> {
    fd := socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    fd < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            sock := TcpSocket {
                fd: fd,
                local_addr: SocketAddr {
                    ip: IpAddr::V4(0, 0, 0, 0),
                    port: 0,
                },
                peer_addr: SocketAddr {
                    ip: IpAddr::V4(0, 0, 0, 0),
                    port: 0,
                },
                is_connected: false,
            }
            return NetResult::Ok(sock)
        }
}

// Connect TCP socket to address
tcp_connect = (sock: TcpSocket, addr: SocketAddr) NetResult<TcpSocket> {
    // Simplified - would need proper sockaddr_in structure
    // This is a placeholder implementation
    result := 0  // connect(sock.fd, addr_struct, sizeof(addr_struct))
    
    result < 0 ?
        | true => {
            return NetResult::Err(NetError::ConnectionRefused)
        }
        | false => {
            sock.peer_addr = addr
            sock.is_connected = true
            return NetResult::Ok(sock)
        }
}

// Send data over TCP socket
tcp_send = (sock: TcpSocket, data: *i8, len: i64) NetResult<i64> {
    sock.is_connected ?
        | false => {
            return NetResult::Err(NetError::NotConnected)
        }
        | true => {}
    
    sent := send(sock.fd, data, len, 0)
    sent < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            return NetResult::Ok(sent)
        }
}

// Receive data from TCP socket
tcp_recv = (sock: TcpSocket, buffer: *i8, max_len: i64) NetResult<i64> {
    sock.is_connected ?
        | false => {
            return NetResult::Err(NetError::NotConnected)
        }
        | true => {}
    
    received := recv(sock.fd, buffer, max_len, 0)
    received < 0 ?
        | true => {
            return NetResult::Err(NetError::ConnectionReset)
        }
        | false => {
            received == 0 ?
                | true => {
                    return NetResult::Err(NetError::ConnectionAborted)
                }
                | false => {
                    return NetResult::Ok(received)
                }
        }
}

// Close TCP socket
tcp_close = (sock: TcpSocket) NetResult<bool> {
    result := close(sock.fd)
    result < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            return NetResult::Ok(true)
        }
}

// Create TCP listener
tcp_listener_new = (addr: SocketAddr) NetResult<TcpListener> {
    fd := socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    fd < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {}
    
    // Enable address reuse
    opt_val := 1
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt_val, 4)
    
    // Bind would need proper sockaddr_in structure
    // This is simplified
    bind_result := 0  // bind(fd, addr_struct, sizeof(addr_struct))
    bind_result < 0 ?
        | true => {
            close(fd)
            return NetResult::Err(NetError::AddrInUse)
        }
        | false => {}
    
    listen_result := listen(fd, 128)  // Backlog of 128
    listen_result < 0 ?
        | true => {
            close(fd)
            return NetResult::Err(NetError::Other)
        }
        | false => {}
    
    listener := TcpListener {
        fd: fd,
        local_addr: addr,
        is_listening: true,
    }
    
    return NetResult::Ok(listener)
}

// Accept connection on TCP listener
tcp_accept = (listener: TcpListener) NetResult<TcpSocket> {
    listener.is_listening ?
        | false => {
            return NetResult::Err(NetError::Other)
        }
        | true => {}
    
    // Simplified - would need proper sockaddr_in structure
    client_fd := accept(listener.fd, 0, 0)
    client_fd < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            sock := TcpSocket {
                fd: client_fd,
                local_addr: listener.local_addr,
                peer_addr: SocketAddr {
                    ip: IpAddr::V4(0, 0, 0, 0),
                    port: 0,
                },
                is_connected: true,
            }
            return NetResult::Ok(sock)
        }
}

// Create UDP socket
udp_socket_new = () NetResult<UdpSocket> {
    fd := socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
    fd < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            sock := UdpSocket {
                fd: fd,
                local_addr: SocketAddr {
                    ip: IpAddr::V4(0, 0, 0, 0),
                    port: 0,
                },
                is_bound: false,
            }
            return NetResult::Ok(sock)
        }
}

// Bind UDP socket to address
udp_bind = (sock: UdpSocket, addr: SocketAddr) NetResult<UdpSocket> {
    // Simplified - would need proper sockaddr_in structure
    bind_result := 0  // bind(sock.fd, addr_struct, sizeof(addr_struct))
    bind_result < 0 ?
        | true => {
            return NetResult::Err(NetError::AddrInUse)
        }
        | false => {
            sock.local_addr = addr
            sock.is_bound = true
            return NetResult::Ok(sock)
        }
}

// Send data to address via UDP
udp_send_to = (sock: UdpSocket, data: *i8, len: i64, addr: SocketAddr) NetResult<i64> {
    // Simplified - would need proper sockaddr_in structure
    sent := sendto(sock.fd, data, len, 0, 0, 0)
    sent < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            return NetResult::Ok(sent)
        }
}

// Receive data from UDP socket
udp_recv_from = (sock: UdpSocket, buffer: *i8, max_len: i64) NetResult<i64> {
    // Simplified - would also return sender address
    received := recvfrom(sock.fd, buffer, max_len, 0, 0, 0)
    received < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            return NetResult::Ok(received)
        }
}

// Close UDP socket
udp_close = (sock: UdpSocket) NetResult<bool> {
    result := close(sock.fd)
    result < 0 ?
        | true => {
            return NetResult::Err(NetError::Other)
        }
        | false => {
            return NetResult::Ok(true)
        }
}

// Helper to create IPv4 address
ipv4_addr = (a: i8, b: i8, c: i8, d: i8) IpAddr {
    return IpAddr::V4(a, b, c, d)
}

// Helper to create socket address
socket_addr = (ip: IpAddr, port: i16) SocketAddr {
    return SocketAddr {
        ip: ip,
        port: port,
    }
}

// Export main types and functions
export {
    // Types
    AddressFamily,
    SocketType,
    NetError,
    NetResult,
    IpAddr,
    SocketAddr,
    TcpSocket,
    UdpSocket,
    TcpListener,
    
    // TCP functions
    tcp_socket_new,
    tcp_connect,
    tcp_send,
    tcp_recv,
    tcp_close,
    tcp_listener_new,
    tcp_accept,
    
    // UDP functions
    udp_socket_new,
    udp_bind,
    udp_send_to,
    udp_recv_from,
    udp_close,
    
    // Helper functions
    ipv4_addr,
    socket_addr,
    
    // Constants
    DEFAULT_BUFFER_SIZE,
    SHUT_RD,
    SHUT_WR,
    SHUT_RDWR,
}