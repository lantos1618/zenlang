// Zen Standard Library: Process Module
// Process management and execution utilities

comptime {
    core := @std.core
    io := @std.io
    string := @std.string
}

// Process exit codes
EXIT_SUCCESS :: 0
EXIT_FAILURE :: 1

// Process ID type
ProcessId = i32

// Process status
ProcessStatus = 
    | Running(pid: ProcessId)
    | Exited(code: i32)
    | Signaled(signal: i32)
    | Stopped(signal: i32)

// Command builder for spawning processes
Command = {
    program: string,
    args: [string],
    env: [(string, string)],
    working_dir: core.Option<string>,
    stdin: core.Option<string>,
    capture_stdout: bool,
    capture_stderr: bool,
}

// Process handle
Process = {
    pid: ProcessId,
    command: Command,
    status: ProcessStatus,
    stdout: core.Option<string>,
    stderr: core.Option<string>,
}

// Create a new command
command = (program: string) Command {
    Command {
        program: program,
        args: [],
        env: [],
        working_dir: core.Option::None,
        stdin: core.Option::None,
        capture_stdout: false,
        capture_stderr: false,
    }
}

// Add an argument to the command
add_arg = (cmd: Command, arg: string) Command {
    new_args := cmd.args.copy()
    new_args.push(arg)
    Command {
        program: cmd.program,
        args: new_args,
        env: cmd.env,
        working_dir: cmd.working_dir,
        stdin: cmd.stdin,
        capture_stdout: cmd.capture_stdout,
        capture_stderr: cmd.capture_stderr,
    }
}

// Add multiple arguments
add_args = (cmd: Command, args: [string]) Command {
    new_args := cmd.args.copy()
    range(0, args.len()).loop(i -> {
        new_args.push(args[i])
    })
    Command {
        program: cmd.program,
        args: new_args,
        env: cmd.env,
        working_dir: cmd.working_dir,
        stdin: cmd.stdin,
        capture_stdout: cmd.capture_stdout,
        capture_stderr: cmd.capture_stderr,
    }
}

// Set environment variable
set_env = (cmd: Command, key: string, value: string) Command {
    new_env := cmd.env.copy()
    new_env.push((key, value))
    Command {
        program: cmd.program,
        args: cmd.args,
        env: new_env,
        working_dir: cmd.working_dir,
        stdin: cmd.stdin,
        capture_stdout: cmd.capture_stdout,
        capture_stderr: cmd.capture_stderr,
    }
}

// Set working directory
set_dir = (cmd: Command, dir: string) Command {
    Command {
        program: cmd.program,
        args: cmd.args,
        env: cmd.env,
        working_dir: core.Option::Some(dir),
        stdin: cmd.stdin,
        capture_stdout: cmd.capture_stdout,
        capture_stderr: cmd.capture_stderr,
    }
}

// Set stdin
set_stdin = (cmd: Command, input: string) Command {
    Command {
        program: cmd.program,
        args: cmd.args,
        env: cmd.env,
        working_dir: cmd.working_dir,
        stdin: core.Option::Some(input),
        capture_stdout: cmd.capture_stdout,
        capture_stderr: cmd.capture_stderr,
    }
}

// Capture stdout
capture_stdout = (cmd: Command) Command {
    Command {
        program: cmd.program,
        args: cmd.args,
        env: cmd.env,
        working_dir: cmd.working_dir,
        stdin: cmd.stdin,
        capture_stdout: true,
        capture_stderr: cmd.capture_stderr,
    }
}

// Capture stderr
capture_stderr = (cmd: Command) Command {
    Command {
        program: cmd.program,
        args: cmd.args,
        env: cmd.env,
        working_dir: cmd.working_dir,
        stdin: cmd.stdin,
        capture_stdout: cmd.capture_stdout,
        capture_stderr: true,
    }
}

// Spawn a process (non-blocking)
spawn = (cmd: Command) core.Result<Process, core.Error> {
    // In a real implementation, this would use system calls
    // For now, return a mock process
    pid := 1234  // Mock PID
    
    core.Result::Ok(Process {
        pid: pid,
        command: cmd,
        status: ProcessStatus::Running(pid),
        stdout: core.Option::None,
        stderr: core.Option::None,
    })
}

// Execute a command and wait for completion
execute = (cmd: Command) core.Result<Process, core.Error> {
    // Spawn the process
    proc_result := spawn(cmd)
    
    proc_result ? 
    | core.Result::Ok(proc) => {
        // Wait for completion (mock implementation)
        completed_proc := Process {
            pid: proc.pid,
            command: proc.command,
            status: ProcessStatus::Exited(0),
            stdout: proc.command.capture_stdout ? 
                | true => core.Option::Some("mock stdout output")
                | false => core.Option::None,
            stderr: proc.command.capture_stderr ?
                | true => core.Option::Some("")
                | false => core.Option::None,
        }
        core.Result::Ok(completed_proc)
    }
    | core.Result::Err(err) => core.Result::Err(err)
}

// Get current process ID
get_pid = () ProcessId {
    // Mock implementation
    42
}

// Get parent process ID
get_ppid = () ProcessId {
    // Mock implementation
    1
}

// Exit the current process
exit = (code: i32) void {
    core.exit(code)
}

// Abort the current process
abort = () void {
    core.panic("Process aborted")
}

// Get command line arguments
args = () [string] {
    // In a real implementation, this would get actual args
    // For now, return mock args
    ["zen", "program.zen"]
}

// Get environment variable
get_env = (key: string) core.Option<string> {
    // Mock implementation
    key == "PATH" ? 
    | true => core.Option::Some("/usr/bin:/bin")
    | false => core.Option::None
}

// Set environment variable
set_env_var = (key: string, value: string) core.Result<void, core.Error> {
    // Mock implementation
    core.Result::Ok(void)
}

// Remove environment variable
unset_env = (key: string) core.Result<void, core.Error> {
    // Mock implementation
    core.Result::Ok(void)
}

// Get current working directory
current_dir = () core.Result<string, core.Error> {
    // Mock implementation
    core.Result::Ok("/home/user")
}

// Change current working directory
set_current_dir = (path: string) core.Result<void, core.Error> {
    // Mock implementation
    core.Result::Ok(void)
}

// Check if process is still running
is_running = (proc: Process) bool {
    proc.status ? 
    | ProcessStatus::Running(_) => true
    | _ => false
}

// Get exit code from process
exit_code = (proc: Process) core.Option<i32> {
    proc.status ?
    | ProcessStatus::Exited(code) => core.Option::Some(code)
    | _ => core.Option::None
}

// Kill a process
kill = (pid: ProcessId) core.Result<void, core.Error> {
    // Mock implementation
    core.Result::Ok(void)
}

// Export public API
export {
    // Constants
    EXIT_SUCCESS,
    EXIT_FAILURE,
    
    // Types
    ProcessId,
    ProcessStatus,
    Command,
    Process,
    
    // Command building
    command,
    add_arg,
    add_args,
    set_env,
    set_dir,
    set_stdin,
    capture_stdout,
    capture_stderr,
    
    // Process execution
    spawn,
    execute,
    
    // Process management
    get_pid,
    get_ppid,
    exit,
    abort,
    args,
    
    // Environment
    get_env,
    set_env_var,
    unset_env,
    
    // Working directory
    current_dir,
    set_current_dir,
    
    // Process utilities
    is_running,
    exit_code,
    kill,
}