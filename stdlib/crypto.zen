// Basic cryptographic utilities for Zen
// Note: These are educational implementations and should not be used for real security

comptime {
    std := @std
    core := std.core
}

// Simple hash function (FNV-1a 32-bit)
fnv1a_32 = (data: []u8, len: usize) u32 {
    hash ::= 2166136261: u32  // FNV offset basis
    prime := 16777619: u32     // FNV prime
    
    i ::= 0: usize
    loop i < len {
        hash = hash ^ data[i]: u32
        hash = hash * prime
        i = i + 1
    }
    hash
}

// Simple hash function (FNV-1a 64-bit)
fnv1a_64 = (data: []u8, len: usize) u64 {
    hash ::= 14695981039346656037: u64  // FNV offset basis
    prime := 1099511628211: u64         // FNV prime
    
    i ::= 0: usize
    loop i < len {
        hash = hash ^ data[i]: u64
        hash = hash * prime
        i = i + 1
    }
    hash
}

// DJB2 hash function
djb2_hash = (data: []u8, len: usize) u64 {
    hash ::= 5381: u64
    
    i ::= 0: usize
    loop i < len {
        hash = ((hash << 5) + hash) + data[i]: u64  // hash * 33 + byte
        i = i + 1
    }
    hash
}

// Simple XOR cipher (for demonstration only - NOT secure!)
xor_cipher = (data:: Ref<Array<u8>>, len: usize, key: []u8, key_len: usize) void {
    key_len == 0 ? | true => return
                   | false => {}
    
    i ::= 0: usize
    loop i < len {
        data[i] = data[i] ^ key[i % key_len]
        i = i + 1
    }
}

// Rotate left for u32
rotl32 = (x: u32, n: u8) u32 {
    n_mod := n % 32
    n_mod == 0 ? | true => x
                | false => (x << n_mod) | (x >> (32 - n_mod))
}

// Rotate right for u32
rotr32 = (x: u32, n: u8) u32 {
    n_mod := n % 32
    n_mod == 0 ? | true => x
                | false => (x >> n_mod) | (x << (32 - n_mod))
}

// Simple checksum
checksum8 = (data: []u8, len: usize) u8 {
    sum ::= 0: u8
    i ::= 0: usize
    loop i < len {
        sum = sum + data[i]
        i = i + 1
    }
    sum
}

// Fletcher-16 checksum
fletcher16 = (data: []u8, len: usize) u16 {
    sum1 ::= 0: u16
    sum2 ::= 0: u16
    
    i ::= 0: usize
    loop i < len {
        sum1 = (sum1 + data[i]: u16) % 255
        sum2 = (sum2 + sum1) % 255
        i = i + 1
    }
    
    (sum2 << 8) | sum1
}

// Simple pseudo-random number generator (Linear Congruential Generator)
// NOT cryptographically secure!
LCGState = {
    seed:: u64,
}

lcg_init = (seed: u64) LCGState {
    LCGState { seed: seed }
}

lcg_next = (state:: Ref<LCGState>) u64 {
    // Parameters from Numerical Recipes
    a := 1664525: u64
    c := 1013904223: u64
    state.seed = (a * state.seed + c)
    state.seed
}

// Generate pseudo-random bytes (NOT secure!)
pseudo_random_bytes = (state:: Ref<LCGState>, buffer:: Ref<Array<u8>>, len: usize) void {
    i ::= 0: usize
    loop i < len {
        value := lcg_next(state)
        buffer[i] = (value >> ((i % 8) * 8)): u8
        i = i + 1
    }
}

// Simple message authentication code (MAC) using XOR and hash
// NOT cryptographically secure - for educational purposes only
simple_mac = (message: []u8, msg_len: usize, key: []u8, key_len: usize) u64 {
    // Combine key and message
    combined_len := key_len + msg_len
    combined := array_new<u8>(combined_len)
    
    // Copy key
    i ::= 0: usize
    loop i < key_len {
        combined[i] = key[i]
        i = i + 1
    }
    
    // Copy message
    i = 0
    loop i < msg_len {
        combined[key_len + i] = message[i]
        i = i + 1
    }
    
    // Hash the combined data
    fnv1a_64(combined, combined_len)
}

// Constant-time comparison (helps prevent timing attacks)
constant_time_compare = (a: []u8, b: []u8, len: usize) bool {
    result ::= 0: u8
    
    i ::= 0: usize
    loop i < len {
        result = result | (a[i] ^ b[i])
        i = i + 1
    }
    
    result == 0
}

// Simple key derivation using repeated hashing
// NOT cryptographically secure - for educational purposes only
derive_key = (password: []u8, pass_len: usize, salt: []u8, salt_len: usize, iterations: u32, output:: Ref<Array<u8>>, out_len: usize) void {
    // Combine password and salt
    combined_len := pass_len + salt_len
    combined := array_new<u8>(combined_len)
    
    // Copy password
    i ::= 0: usize
    loop i < pass_len {
        combined[i] = password[i]
        i = i + 1
    }
    
    // Copy salt
    i = 0
    loop i < salt_len {
        combined[pass_len + i] = salt[i]
        i = i + 1
    }
    
    // Hash repeatedly
    hash ::= fnv1a_64(combined, combined_len)
    iter ::= 1: u32
    loop iter < iterations {
        // Use previous hash as new input
        hash_bytes := [
            (hash >> 56): u8,
            (hash >> 48): u8,
            (hash >> 40): u8,
            (hash >> 32): u8,
            (hash >> 24): u8,
            (hash >> 16): u8,
            (hash >> 8): u8,
            hash: u8,
        ]
        hash = fnv1a_64(hash_bytes, 8)
        iter = iter + 1
    }
    
    // Fill output with derived bytes
    i = 0
    loop i < out_len && i < 8 {
        output[i] = (hash >> ((7 - i) * 8)): u8
        i = i + 1
    }
    
    // If need more bytes, hash again
    loop i < out_len {
        hash = fnv1a_64(output, i)
        j ::= 0: usize
        loop j < 8 && i < out_len {
            output[i] = (hash >> ((7 - j) * 8)): u8
            i = i + 1
            j = j + 1
        }
    }
}