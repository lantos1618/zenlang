// String utility functions for the Zen standard library
// Essential string operations for self-hosting

extern strlen = (str: *i8) i64
extern strcmp = (s1: *i8, s2: *i8) i32
extern strncmp = (s1: *i8, s2: *i8, n: i64) i32
extern strcpy = (dest: *i8, src: *i8) *i8
extern strncpy = (dest: *i8, src: *i8, n: i64) *i8
extern memcpy = (dest: *void, src: *void, n: i64) *void
extern malloc = (size: i64) *void
extern free = (ptr: *void) void

// String comparison - returns true if strings are equal
string_equals = (s1: *i8, s2: *i8) bool {
    return strcmp(s1, s2) == 0
}

// String comparison with length limit
string_equals_n = (s1: *i8, s2: *i8, n: i64) bool {
    return strncmp(s1, s2, n) == 0
}

// Get string length
string_len = (str: *i8) i64 {
    return strlen(str)
}

// Copy string to new allocation
string_copy = (src: *i8) *i8 {
    len := strlen(src)
    dest := malloc(len + 1) as *i8
    strcpy(dest, src)
    return dest
}

// Copy n characters from string
string_copy_n = (src: *i8, n: i64) *i8 {
    dest := malloc(n + 1) as *i8
    strncpy(dest, src, n)
    dest[n] = 0 // null terminate
    return dest
}

// Concatenate two strings
string_concat = (s1: *i8, s2: *i8) *i8 {
    len1 := strlen(s1)
    len2 := strlen(s2)
    total := len1 + len2
    
    result := malloc(total + 1) as *i8
    memcpy(result as *void, s1 as *void, len1)
    memcpy((result + len1) as *void, s2 as *void, len2)
    result[total] = 0
    
    return result
}

// Check if string starts with prefix
string_starts_with = (str: *i8, prefix: *i8) bool {
    prefix_len := strlen(prefix)
    str_len := strlen(str)
    
    str_len < prefix_len ? | true => { return false } | false => {}
    
    return strncmp(str, prefix, prefix_len) == 0
}

// Check if string ends with suffix
string_ends_with = (str: *i8, suffix: *i8) bool {
    suffix_len := strlen(suffix)
    str_len := strlen(str)
    
    str_len < suffix_len ? | true => { return false } | false => {}
    
    offset := str_len - suffix_len
    return strcmp(str + offset, suffix) == 0
}

// Find character in string - returns index or -1 if not found
string_find_char = (str: *i8, ch: i8) i64 {
    i := 0 as i64
    loop {
        str[i] == 0 ? | true => { return -1 } | false => {}
        str[i] == ch ? | true => { return i } | false => {}
        i = i + 1
    }
}

// Find last occurrence of character - returns index or -1 if not found
string_find_char_reverse = (str: *i8, ch: i8) i64 {
    len := strlen(str)
    len == 0 ? | true => { return -1 } | false => {}
    
    i := len - 1
    loop {
        str[i] == ch ? | true => { return i } | false => {}
        i == 0 ? | true => { return -1 } | false => {}
        i = i - 1
    }
}

// Convert ASCII character to lowercase
char_to_lower = (ch: i8) i8 {
    ch >= 65 && ch <= 90 ? | true => { return ch + 32 } | false => { return ch }
}

// Convert ASCII character to uppercase
char_to_upper = (ch: i8) i8 {
    ch >= 97 && ch <= 122 ? | true => { return ch - 32 } | false => { return ch }
}

// Convert string to lowercase (modifies in place)
string_to_lower = (str:: *i8) void {
    i := 0 as i64
    loop {
        str[i] == 0 ? | true => break | false => {}
        str[i] = char_to_lower(str[i])
        i = i + 1
    }
}

// Convert string to uppercase (modifies in place)
string_to_upper = (str:: *i8) void {
    i := 0 as i64
    loop {
        str[i] == 0 ? | true => break | false => {}
        str[i] = char_to_upper(str[i])
        i = i + 1
    }
}

// Create substring from start index with length
string_substring = (str: *i8, start: i64, len: i64) *i8 {
    str_len := strlen(str)
    
    // Bounds checking
    start >= str_len ? | true => {
        result := malloc(1) as *i8
        result[0] = 0
        return result
    } | false => {}
    
    // Adjust length if necessary
    actual_len := start + len > str_len ? 
        | true => str_len - start
        | false => len
    
    result := malloc(actual_len + 1) as *i8
    memcpy(result as *void, (str + start) as *void, actual_len)
    result[actual_len] = 0
    
    return result
}

// Trim whitespace from both ends of string (returns new string)
string_trim = (str: *i8) *i8 {
    start := 0 as i64
    end := strlen(str)
    
    end == 0 ? | true => { return string_copy("") } | false => {}
    end = end - 1
    
    // Trim from start
    loop {
        ch := str[start]
        ch == 0 ? | true => break | false => {}
        ch == 32 || ch == 9 || ch == 10 || ch == 13 ? | false => break | true => {}
        start = start + 1
    }
    
    // Trim from end
    loop {
        end < start ? | true => break | false => {}
        ch := str[end]
        ch == 32 || ch == 9 || ch == 10 || ch == 13 ? | false => break | true => {}
        end = end - 1
    }
    
    // Calculate length
    len := end >= start ? | true => end - start + 1 | false => 0
    
    len == 0 ? | true => { return string_copy("") } | false => {}
    
    result := malloc(len + 1) as *i8
    memcpy(result as *void, (str + start) as *void, len)
    result[len] = 0
    
    return result
}

// Check if character is a digit
is_digit = (ch: i8) bool {
    return ch >= 48 && ch <= 57
}

// Check if character is a letter
is_alpha = (ch: i8) bool {
    return (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122)
}

// Check if character is alphanumeric
is_alnum = (ch: i8) bool {
    return is_alpha(ch) || is_digit(ch)
}

// Parse integer from string (simple version, no error handling)
string_to_int = (str: *i8) i64 {
    result := 0 as i64
    sign := 1 as i64
    i := 0 as i64
    
    // Handle sign
    str[0] == 45 ? // '-'
        | true => {
            sign = -1
            i = 1
        }
        | false => {
            str[0] == 43 ? // '+'
                | true => { i = 1 }
                | false => {}
        }
    
    // Parse digits
    loop {
        ch := str[i]
        ch == 0 ? | true => break | false => {}
        is_digit(ch) ? | false => break | true => {}
        
        digit := (ch - 48) as i64
        result = result * 10 + digit
        i = i + 1
    }
    
    return result * sign
}