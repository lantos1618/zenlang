// Zen Standard Library: Iterator Module
// Provides functional iteration patterns for collections

comptime {
    core := @std.core
}

// Range iterator for numeric ranges
Range = {
    start: i64,
    end: i64,
    current: i64,
}

// Create a range from start to end (exclusive)
range = (start: i64, end: i64) Range {
    return Range {
        start: start,
        end: end,
        current: start,
    }
}

// Loop method for Range - executes callback for each value
Range.loop = (self:: *Range, callback: (i64) void) void {
    loop self.current < self.end {
        callback(self.current)
        self.current = self.current + 1
    }
}

// Generic iterator interface
Iterator<T> = {
    data: *T,
    size: i64,
    current: i64,
}

// Create iterator from array
array_iter<T> = (arr: *T, size: i64) Iterator<T> {
    return Iterator<T> {
        data: arr,
        size: size,
        current: 0,
    }
}

// Check if iterator has next element
Iterator<T>.has_next = (self: Iterator<T>) bool {
    return self.current < self.size
}

// Get next element
Iterator<T>.next = (self:: *Iterator<T>) Option<T> {
    self.current >= self.size ? 
        | true => return Option<T>::None
        | false => {
            idx := self.current
            self.current = self.current + 1
            // Note: Array indexing would be: self.data[idx]
            // For now using pointer arithmetic concept
            return Option<T>::Some(*((self.data as i64) + idx * sizeof(T)))
        }
}

// Loop method for Iterator - executes callback for each element
Iterator<T>.loop = (self:: *Iterator<T>, callback: (T) void) void {
    loop self.current < self.size {
        // callback(self.data[self.current])
        self.current = self.current + 1
    }
}

// Functional iteration methods (alias for compatibility)
Iterator<T>.for_each = (self:: *Iterator<T>, callback: (T) void) void {
    self.loop(callback)
}

// Map iterator to new values
Iterator<T>.map<U> = (self: Iterator<T>, transform: (T) U) Iterator<U> {
    // Implementation would require dynamic allocation
    // Placeholder for concept
    return Iterator<U> { 
        data: 0 as *U,
        size: 0,
        current: 0,
    }
}

// Filter iterator
Iterator<T>.filter = (self: Iterator<T>, predicate: (T) bool) Iterator<T> {
    // Implementation would require dynamic allocation
    // Placeholder for concept
    return Iterator<T> {
        data: self.data,
        size: self.size,
        current: 0,
    }
}

// Reduce/fold operation
Iterator<T>.reduce<U> = (self: Iterator<T>, initial: U, accumulator: (U, T) U) U {
    result ::= initial
    i ::= 0
    loop i < self.size {
        // result = accumulator(result, self.data[i])
        i = i + 1
    }
    return result
}

// Sum numeric iterator (for i32)
sum_i32 = (iter:: *Iterator<i32>) i32 {
    sum ::= 0
    iter.loop(value -> {
        sum = sum + value
    })
    return sum
}

// Find first element matching predicate
Iterator<T>.find = (self:: *Iterator<T>, predicate: (T) bool) Option<T> {
    result ::= Option<T>::None
    self.loop(value -> {
        predicate(value) ?
            | true => result = Option<T>::Some(value)
            | false => {}
    })
    return result
}

// Check if any element matches predicate
Iterator<T>.any = (self:: *Iterator<T>, predicate: (T) bool) bool {
    found ::= false
    self.loop(value -> {
        predicate(value) ?
            | true => found = true
            | false => {}
    })
    return found
}

// Check if all elements match predicate
Iterator<T>.all = (self:: *Iterator<T>, predicate: (T) bool) bool {
    all_match ::= true
    self.loop(value -> {
        predicate(value) ?
            | false => all_match = false
            | true => {}
    })
    return all_match
}

// Count elements matching predicate
Iterator<T>.count = (self:: *Iterator<T>, predicate: (T) bool) i64 {
    count ::= 0
    self.loop(value -> {
        predicate(value) ?
            | true => count = count + 1
            | false => {}
    })
    return count
}

// Take first n elements
Iterator<T>.take = (self: Iterator<T>, n: i64) Iterator<T> {
    new_size := n < self.size ? | true => n | false => self.size
    return Iterator<T> {
        data: self.data,
        size: new_size,
        current: 0,
    }
}

// Skip first n elements
Iterator<T>.skip = (self: Iterator<T>, n: i64) Iterator<T> {
    n >= self.size ? 
        | true => return Iterator<T> { data: self.data, size: 0, current: 0 }
        | false => {}
    
    // Would need pointer arithmetic to skip elements
    return Iterator<T> {
        data: self.data,  // Should be: self.data + n
        size: self.size - n,
        current: 0,
    }
}

// Chain two iterators
Iterator<T>.chain = (self: Iterator<T>, other: Iterator<T>) Iterator<T> {
    // Would need dynamic allocation to combine
    return Iterator<T> {
        data: self.data,
        size: self.size + other.size,
        current: 0,
    }
}

// Zip two iterators into pairs
zip<T, U> = (iter1: Iterator<T>, iter2: Iterator<U>) Iterator<Pair<T, U>> {
    // Placeholder for concept
    min_size := iter1.size < iter2.size ? 
        | true => iter1.size 
        | false => iter2.size
    
    return Iterator<Pair<T, U>> {
        data: 0 as *Pair<T, U>,
        size: min_size,
        current: 0,
    }
}

// Pair type for zip
Pair<T, U> = {
    first: T,
    second: U,
}

// Enumerate iterator with indices
Iterator<T>.enumerate = (self: Iterator<T>) Iterator<Pair<i64, T>> {
    // Would return pairs of (index, value)
    return Iterator<Pair<i64, T>> {
        data: 0 as *Pair<i64, T>,
        size: self.size,
        current: 0,
    }
}

// Additional functional operations

// Flat map - map and flatten results
Iterator<T>.flat_map<U> = (self: Iterator<T>, f: (T) Iterator<U>) Iterator<U> {
    // Conceptual implementation - would need dynamic allocation
    return Iterator<U> {
        data: 0 as *U,
        size: 0,
        current: 0,
    }
}

// Partition iterator into two based on predicate
Iterator<T>.partition = (self:: *Iterator<T>, predicate: (T) bool) (Iterator<T>, Iterator<T>) {
    // Would split into (matching, non-matching)
    matching := Iterator<T> { data: 0 as *T, size: 0, current: 0 }
    non_matching := Iterator<T> { data: 0 as *T, size: 0, current: 0 }
    return (matching, non_matching)
}

// Collect iterator into a Vec
Iterator<T>.collect = (self:: *Iterator<T>) Vec<T> {
    result := Vec<T>::new()
    self.loop(item -> {
        result.push(item)
    })
    return result
}

// Find the maximum element (for comparable types)
Iterator<T>.max = (self:: *Iterator<T>, compare: (T, T) i32) Option<T> {
    self.size == 0 ? | true => return Option<T>::None
                     | false => {}
    
    max_val ::= Option<T>::None
    self.loop(value -> {
        max_val ? | .None => max_val = Option<T>::Some(value)
                 | .Some -> current => {
                     compare(value, current) > 0 ?
                         | true => max_val = Option<T>::Some(value)
                         | false => {}
                 }
    })
    return max_val
}

// Find the minimum element (for comparable types)
Iterator<T>.min = (self:: *Iterator<T>, compare: (T, T) i32) Option<T> {
    self.size == 0 ? | true => return Option<T>::None
                     | false => {}
    
    min_val ::= Option<T>::None
    self.loop(value -> {
        min_val ? | .None => min_val = Option<T>::Some(value)
                 | .Some -> current => {
                     compare(value, current) < 0 ?
                         | true => min_val = Option<T>::Some(value)
                         | false => {}
                 }
    })
    return min_val
}

// Reverse the iterator
Iterator<T>.reverse = (self: Iterator<T>) Iterator<T> {
    // Would need to reverse the underlying data
    return Iterator<T> {
        data: self.data,
        size: self.size,
        current: 0,
    }
}

// Cycle through iterator infinitely
Iterator<T>.cycle = (self: Iterator<T>) Iterator<T> {
    // Would create an infinite iterator
    return Iterator<T> {
        data: self.data,
        size: -1,  // Special marker for infinite
        current: 0,
    }
}

// Peek at next element without consuming
Iterator<T>.peek = (self: Iterator<T>) Option<T> {
    self.current >= self.size ?
        | true => return Option<T>::None
        | false => {
            // Return current element without advancing
            return Option<T>::Some(self.data[self.current])
        }
}

// Step by n elements
Iterator<T>.step_by = (self: Iterator<T>, n: i64) Iterator<T> {
    // Would skip n-1 elements between each yield
    return Iterator<T> {
        data: self.data,
        size: (self.size + n - 1) / n,  // Ceiling division
        current: 0,
    }
}

// Window sliding iterator
Iterator<T>.windows = (self: Iterator<T>, window_size: i64) Iterator<[]T> {
    // Would yield overlapping windows of size window_size
    return Iterator<[]T> {
        data: 0 as *[]T,
        size: self.size > window_size ? | true => self.size - window_size + 1
                                        | false => 0,
        current: 0,
    }
}

// Chunks iterator - non-overlapping groups
Iterator<T>.chunks = (self: Iterator<T>, chunk_size: i64) Iterator<[]T> {
    // Would yield non-overlapping chunks
    return Iterator<[]T> {
        data: 0 as *[]T,
        size: (self.size + chunk_size - 1) / chunk_size,
        current: 0,
    }
}

// Intersperse elements between iterator items
Iterator<T>.intersperse = (self: Iterator<T>, separator: T) Iterator<T> {
    // Would insert separator between elements
    new_size := self.size > 0 ? | true => self.size * 2 - 1
                                | false => 0
    return Iterator<T> {
        data: self.data,
        size: new_size,
        current: 0,
    }
}

// Group consecutive equal elements
Iterator<T>.group_by<K> = (self: Iterator<T>, key_fn: (T) K) Iterator<(K, []T)> {
    // Would group consecutive elements with same key
    return Iterator<(K, []T)> {
        data: 0 as *(K, []T),
        size: 0,
        current: 0,
    }
}

// Scan - like reduce but yields intermediate results
Iterator<T>.scan<S> = (self: Iterator<T>, initial: S, f: (S, T) S) Iterator<S> {
    // Would yield accumulated values at each step
    return Iterator<S> {
        data: 0 as *S,
        size: self.size,
        current: 0,
    }
}