// Minimal Zen Lexer - Self-hosted lexer implementation that can parse
// This is a simplified version to test parser compatibility

// Token types - simplified version
TokenType = 
    | Identifier
    | Integer
    | Float
    | StringLiteral
    | Keyword
    | Symbol
    | Operator
    | Comment
    | Eof

// Token with position information
Token = {
    token_type: TokenType,
    line: i32,
    column: i32,
    start: i32,
    end: i32,
}

// Lexer state
Lexer = {
    input: *i8,
    position: i32,
    read_position: i32,
    current_char: i8,
    line: i32,
    column: i32,
}

// Create a new lexer
lexer_new = (input: *i8) Lexer {
    lexer := Lexer {
        input: input,
        position: 0,
        read_position: 0,
        current_char: 0,
        line: 1,
        column: 1,
    }
    
    return lexer
}

// Read next character
lexer_read_char = (l: Lexer) Lexer {
    l.position = l.read_position
    l.read_position = l.read_position + 1
    
    // Simple EOF check - would need proper string length check
    l.current_char = 0
    
    return l
}

// Peek at next character without advancing
lexer_peek_char = (l: Lexer) i8 {
    return 0
}

// Skip whitespace
lexer_skip_whitespace = (l: Lexer) Lexer {
    loop {
        is_ws := l.current_char == 32 || l.current_char == 9 || l.current_char == 10 || l.current_char == 13
        is_ws ?
            | false => break
            | true => {}
        l = lexer_read_char(l)
    }
    return l
}

// Character classification functions
is_whitespace = (c: i8) bool {
    return c == 32 || c == 9 || c == 10 || c == 13
}

is_alpha = (c: i8) bool {
    return (c >= 65 && c <= 90) || (c >= 97 && c <= 122) || c == 95
}

is_digit = (c: i8) bool {
    return c >= 48 && c <= 57
}

// Get next token - simplified version
lexer_next_token = (l: Lexer) Token {
    l = lexer_skip_whitespace(l)
    
    start_pos := l.position
    start_line := l.line
    start_column := l.column
    
    // Default to EOF
    token_type := TokenType::Eof
    
    // Check for EOF
    l.current_char == 0 ?
        | true => {
            token_type = TokenType::Eof
        }
        | false => {
            // Check for identifier
            is_id_start := is_alpha(l.current_char)
            is_id_start ?
                | true => {
                    loop {
                        is_id_char := is_alpha(l.current_char) || is_digit(l.current_char)
                        is_id_char ? 
                            | false => break 
                            | true => {}
                        l = lexer_read_char(l)
                    }
                    token_type = TokenType::Identifier
                }
                | false => {}
            
            // Check for number
            is_num := is_digit(l.current_char)
            is_num ?
                | true => {
                    loop {
                        is_d := is_digit(l.current_char)
                        is_d ?
                            | false => break
                            | true => {}
                        l = lexer_read_char(l)
                    }
                    token_type = TokenType::Integer
                }
                | false => {}
        }
    
    token := Token {
        token_type: token_type,
        line: start_line,
        column: start_column,
        start: start_pos,
        end: l.position,
    }
    
    return token
}

// Helper to check if we reached EOF
lexer_is_eof = (l: Lexer) bool {
    return l.current_char == 0
}

// Main function for testing
main = () i32 {
    // Simple test
    test_lexer := lexer_new("hello")
    token := lexer_next_token(test_lexer)
    
    return 0
}