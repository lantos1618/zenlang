// HTTP Client for Better-UI
import std.string
import std.json
import std.net
import std.result

struct HttpClient {
    base_url: String,
    headers: HashMap<String, String>,
    
    fn new(base_url: String) -> HttpClient {
        return HttpClient {
            base_url: base_url,
            headers: HashMap.new()
        }
    }
    
    fn set_header(key: String, value: String) -> HttpClient {
        self.headers.set(key, value)
        return self
    }
    
    fn get(path: String) -> Result<String, String> {
        let url = self.base_url + path
        let request = HttpRequest {
            method: "GET",
            url: url,
            headers: self.headers,
            body: null
        }
        return self.send(request)
    }
    
    fn post(path: String, body: Any) -> Result<String, String> {
        let url = self.base_url + path
        let json_body = json.stringify(body)
        
        self.headers.set("Content-Type", "application/json")
        
        let request = HttpRequest {
            method: "POST",
            url: url,
            headers: self.headers,
            body: json_body
        }
        return self.send(request)
    }
    
    fn send(request: HttpRequest) -> Result<String, String> {
        // This would connect to actual HTTP implementation
        // For now, returning a placeholder
        return Ok("Response placeholder")
    }
}

struct HttpRequest {
    method: String,
    url: String,
    headers: HashMap<String, String>,
    body: String?
}

// Gemini AI API Client
struct GeminiClient {
    api_key: String,
    client: HttpClient,
    
    fn new(api_key: String) -> GeminiClient {
        let client = HttpClient.new("https://generativelanguage.googleapis.com/v1beta/")
            .set_header("Authorization", "Bearer " + api_key)
            .set_header("Content-Type", "application/json")
            
        return GeminiClient {
            api_key: api_key,
            client: client
        }
    }
    
    fn generate_content(prompt: String, model: String?) -> Result<String, String> {
        let model_name = model ?? "gemini-pro"
        let endpoint = "models/" + model_name + ":generateContent"
        
        let request_body = {
            "contents": [{
                "parts": [{
                    "text": prompt
                }]
            }]
        }
        
        let response = self.client.post(endpoint + "?key=" + self.api_key, request_body)
        
        match response {
            Ok(data) -> {
                let parsed = json.parse(data)
                if parsed.candidates && parsed.candidates.len() > 0 {
                    return Ok(parsed.candidates[0].content.parts[0].text)
                }
                return Err("No response generated")
            },
            Err(e) -> return Err(e)
        }
    }
}

// Stock API Client
struct StockAPIClient {
    client: HttpClient,
    
    fn new() -> StockAPIClient {
        // Using a free stock API (e.g., Alpha Vantage or Yahoo Finance)
        let client = HttpClient.new("https://query1.finance.yahoo.com/v8/finance/")
        
        return StockAPIClient {
            client: client
        }
    }
    
    fn get_quote(symbol: String) -> Result<StockData, String> {
        let endpoint = "quote?symbols=" + symbol
        let response = self.client.get(endpoint)
        
        match response {
            Ok(data) -> {
                let parsed = json.parse(data)
                if parsed.quoteResponse && parsed.quoteResponse.result.len() > 0 {
                    let quote = parsed.quoteResponse.result[0]
                    return Ok(StockData {
                        symbol: quote.symbol,
                        price: quote.regularMarketPrice,
                        change: quote.regularMarketChange,
                        change_percent: quote.regularMarketChangePercent,
                        volume: quote.regularMarketVolume,
                        market_cap: quote.marketCap
                    })
                }
                return Err("Stock not found")
            },
            Err(e) -> return Err(e)
        }
    }
    
    fn get_chart(symbol: String, range: String) -> Result<Vec<ChartPoint>, String> {
        let endpoint = "chart/" + symbol + "?range=" + range + "&interval=1d"
        let response = self.client.get(endpoint)
        
        match response {
            Ok(data) -> {
                let parsed = json.parse(data)
                let timestamps = parsed.chart.result[0].timestamp
                let quotes = parsed.chart.result[0].indicators.quote[0]
                
                let mut points = Vec.new()
                
                (0..timestamps.len()).each(i -> {
                    points.push(ChartPoint {
                        timestamp: timestamps[i],
                        open: quotes.open[i],
                        high: quotes.high[i],
                        low: quotes.low[i],
                        close: quotes.close[i],
                        volume: quotes.volume[i]
                    })
                })
                
                return Ok(points)
            },
            Err(e) -> return Err(e)
        }
    }
}

struct StockData {
    symbol: String,
    price: f64,
    change: f64,
    change_percent: f64,
    volume: i64,
    market_cap: i64
}

struct ChartPoint {
    timestamp: i64,
    open: f64,
    high: f64,
    low: f64,
    close: f64,
    volume: i64
}